# 面向对象分析与设计

## 第三章 关于类和对象的进一步讨论

### 3.1 构造函数

#### 3.1.1 对象的初始化

-   类的数据成员是不能在**声明**类时初始化

    ```c++
    class Time
    {       
    	hour=0;//错误
    	minute=0;
    	sec=0;
    };
    ```

-   因为类不是一个实体，是一种抽象类型，不占存储空间，所以不能容纳数据

-   如果一个类中所有的成员都是公用的，则可以在定义对象时对数据成员进行初始化。

    ```c++
    class Time
    {     
        public://声明为公用成员
        	hour;                        
            minute;
            sec;
    };
    Time t1={14,56,30};//将t1初始化为14:56:30
    ```

#### 3.1.2 构造函数的作用

-   C++提供了**构造函数**(constructor)来处理对象的初始化。
-   构造函数是一种**特殊的成员函数**，不需要用户来调用它，而是在建立对象时**自动执行**。
-   构造函数的名字必须与**类名同名**，而不能由用户任意命名。它**不具有任何类型，不返回任何值**。

```c++
//例3.1
//在例2.3基础上定义构造成员函数。

#include <iostream>
using namespace std;
class Time
{   
    public:
        Time( )//定义构造成员函数，函数名与类名相同
        {   
            hour=0;//利用构造函数对对象中的数据成员赋初值
            minute=0;
            sec=0;  
        }
         void set_time( );//函数声明
         void show_time( );//函数声明
    private:
         int hour;//私有数据成员
         int minute;
         int sec;   
};
void Time∷set_time( )//定义成员函数，向数据成员赋值
{   
    cin>>hour;
	cin>>minute;
	cin>>sec;
}
void Time∷show_time( )//定义成员函数，输出数据成员的值
{
	cout<<hour<<″:″<<minute<<″:″<<sec<<endl;
}
int main( )
{
	Time t1;//建立对象t1，同时调用构造函数t1.Time( )
	t1.set_time( );//对t1的数据成员赋值
	t1.show_time( );//显示t1的数据成员的值 
	Time t2;//建立对象t2，同时调用构造函数t2.Time( )
	t2.show_time( );//显示t2的数据成员的
	return 0;
}
```

在类外定义构造函数:

```c++
Time∷Time( ) 
{
     hour=0;                 
     minute=0;
     sec=0;
}
```



-   在类对象进入其作用域时调用构造函数。
-   构造函数没有返回值，因此也不需要在定义构造函数时声明类型。
-   构造函数不需用户调用，也不能被用户调用。
-   在构造函数的函数体中不仅可以对数据成员赋初值，而且可以包含其他语句。
-   如果用户自己没有定义构造函数，则C++系统会自动生成一个构造函数，该构造函数的函数体是空的，也没有参数，不执行初始化操作。

#### 3.1.3 带参数的构造函数

-   带参数的构造函数，在调用不同对象的构造函数时，从外面将不同的数据传递给构造函数，以实现不同的初始化。
-   构造函数首部的一般格式为
           **构造函数名(类型 1 形参1，类型2 形参2，…)**
        实参是在定义对象时给出的。
        定义对象的一般格式为 
            **类名 对象名(实参1，实参2，…);**

```C++
//例3.2
//有两个长方柱，其长、宽、高分别为： (1)12,20,25;(2)10,14,20。求它们的体积。

#include <iostream>
using namespace std;
class Box
{  
	public:
		Box(int,int,int);//声明带参数的构造函数
        int volume( );//声明计算体积的函数
	private:
        int height;
        int width;
        int length;
};
Box∷Box(int h,int w,int len)//在类外定义带参数的构造函数
{    
    height=h;
	width=w;
	length=len;
}
int Box∷volume( )//定义计算体积的函数
{
     return(height*width*length);
}

int main( )
{
      Box box1(12,25,30);//建立对象box1
      cout<<″The volume of box1 is ″<<box1.volume( )<<endl;
      Box box2(15,30,21);//建立对象box2 
      cout<<″The volume of box2 is ″<<box2.volume( )<<endl;
      return 0;
}
```

#### 3.1.4 用参数初始化表对数据成员初始化

-   不在函数体内对数据成员初始化，而是在函数首部实现。
-   一般格式为
       **Box∷Box(int h,int w,int len): height(h),width(w), length(len){ }**

#### 3.1.5 构造函数的重载

-   在一个类里可以定义多个构造函数，所有的构造函数都同名，只是参数的个数或参数的类型不同。

```c++
//例3.3
//在例3.2的基础上，定义两个构造函数，其中一个无参数，一个有参数。

#include <iostream>
using namespace std;
class Box
{
    public:
		Box( );//声明一个无参的构造函数
		Box(int h,int w,int len):height(h),width(w),length(len){ }//声明一个有参的构造函数
		int volume( );
	private:
		int height;
    	int width;
    	int length;
};
Box∷Box( )//定义一个无参的构造函数
{   
	height=10;
    width=10;
    length=10;
}
int Box∷volume( )
{return(height*width*length);}

int main( )
{
    Box box1;//建立对象box1,不指定实参
    cout<<″The volume of box1 is ″<<box1.volume( )<<endl;
    Box box2(15,30,25);//建立对象box2,指定3个实参
    cout<<″The volume of box2 is ″<<box2.volume( )<<endl;
    return 0;
}

在本程序中定义了两个重载的构造函数，其实还可以定义其他重载构造函数，其原型声明可以为
Box∷Box(int h);//有1个参数的构造函数
Box∷Box(int h,int w);//有两个参数的构造函数
在建立对象时分别给定1个参数和2个参数。
```

-   调用构造函数时不必给出实参的构造函数，称为默认构造函数(default constructor)。无参的构造函数属于默认构造函数。一个类只能有一个默认构造函数。
-   如果在建立对象时选用的是无参构造函数，应注意正确书写定义对象的语句。Box box1;Box box1();
-   尽管在一个类中可以包含多个构造函数，但是对于每一个对象来说，建立对象时只执行其中一个构造函数，并非每个构造函数都被执行。

#### 3.1.6 带默认参数的构造函数

```c++
//例3.4

#include <iostream>
using namespace std;
class Box
{
    public:
    	Box(int h=10,int w=10,int len=10);//指定默认参数
        int volume( );//声明计算体积的函数
   private:
        int height;
        int width;
        int length;
};
Box∷Box(int h,int w,int len)//定义时不用再指定默认值
{    
    height=h;
	width=w;
	length=len;
}
int Box∷volume( )
{
    return(height*width*length);
}
int main( )
{
    Box box1;//没有给实参 
	cout<<″The volume of box1 is ″<<box1.volume( )<<endl;
	Box box2(15);//只给定一个实参
	cout<<″The volume of box2 is ″<<box2.volume( )<<endl;
	Box box3(15,30);//只给定2个实参
	cout<<″The volume of box3 is ″<<box3.volume( )<<endl;
	Box box4(15,30,20);//给定3个实参
    cout<<″The volume of box4 is ″<<box4.volume( )<<endl;
    return 0;
}
```

-   要在**声明**构造函数时指定默认值，而不能只在定义构造函数时指定默认值。

-   在声明构造函数时，形参名可以省略。 

    ```
    Box(int=10,int=10,int=10);
    ```

-   如果构造函数的全部参数都指定了默认值，则在定义对象时可以给一个或几个实参，也可以不给出。

-   一个类只能有一个默认构造函数。

    ```c++
    Box();
    Box(int=10,int=10,int=10);
    Box box1;？
    ```

-   重载时注意歧义出现

       定义对象如下：

    ```c++
    Box();
    Box(int,int=10,int=10);
    Box(int,int);
    ```

       定义对象如下：

    ```c++
    Box box1; 
    Box box2(15); 
    Box box3(15,30);
    ```

### 3.2 析构函数

-   析构函数(destructor)也是一个特殊的成员函数，它的作用与构造函数相反，它的名字是类名的前面加一个“**～**”符号。
-   当对象的生命期结束时，会自动执行析构函数。
    -   ①如果在一个函数中定义了一个对象(它是自动局部对象)，当这个函数被调用结束时，对象应该释放，在对象释放前自动执行析构函数。
    -   ②在main函数结束或调用exit函数结束程序时，调用static局部对象的析构函数。 
    -   ③如果定义了一个全局对象，则在程序的流程离开其作用域时(如main函数结束或调用exit函数) 时，调用该全局对象的析构函数。
    -   ④如果用new运算符动态地建立了一个对象，当用delete运算符释放该对象时，先调用该对象的析构函数。
-   析构函数不是删除对象，而是在撤销对象占用的内存之前完成一些清理工作，使这部分内存可以被程序分配给新对象使用。
-   析构函数不返回任何值，没有函数类型，也没有函数参数。因此它不能被重载。**一个类可以有多个构造函数，但只能有一个析构函数。**
-   析构函数的作用并不仅限于释放资源方面，它还可以完成类的设计者所指定的任何操作。
-   一般情况下，应当在声明类的同时定义析构函数。如果用户没有定义析构函数，C++编译系统会自动生成一个析构函数，但什么操作都不进行。

```C++
//例3.5
//包含构造函数和析构函数的C++程序。

#include<string>
#include<iostream>
using namespace std;
class Student//声明Student类
{   
	public:
		Student(int n,string nam,char s )//定义构造函
        {
			num=n;
			name=nam;
           	sex=s;
           	cout<<″Constructor called.″<<endl;//输出有关信息
        }
    	~Student( )//定义析构函数
    	{
        	cout<<″Destructor called.″<<endl;//输出有关信息
    	}
		void display( )//定义成员函数
		{
        	cout<<″num: ″<<num<<endl;
			cout<<″name: ″<<name<<endl;
			cout<<″sex: ″<<sex<<endl<<endl;
    	}
    private:
    	int num;
    	string name;
    	char sex;
};

int main( )
{
    Student stud1(10010,”Wang_li”,’f’);//建立对象stud1
	stud1.display( );//输出学生1的数据  
	Student stud2(10011,”Zhang_fun”,’m’);//定义对象stud2
	stud2.display( );//输出学生2的数据
	return 0;
}

程序运行结果如下： 
Constructor called.               (执行stud1的构造函数)
num: 10010                        (执行stud1的display函数)
name:Wang_li
sex: f

Constructor called.               (执行stud2的构造函数)
num: 10011                        (执行stud2的display函数)
name:Zhang_fun
sex:m
Destructor called.                (执行stud2的析构函数)
Destructor called.                (执行stud1的析构函数)
```

### 3.3调用构造函数和析构函数的顺序

-   调用析构函数的次序正好与调用构造函数的次序相反： 最先被调用的构造函数，其对应的(同一对象中的)析构函数最后被调用，而最后被调用的构造函数，其对应的析构函数最先被调用。
-   **先构造后析构，后构造先析构。**
-   但有时会受生命期和作用域的影响

<img src="https://github.com/LvFinch/ImgHost/raw/master/Images/image-20200523095345955.png" alt="img3_3" style="zoom: 67%;" />

### 3.4 对象数组

-   数组可以由对象组成(对象数组的每一个元素都是同类的对象)。

    ```c++
    Student stud[50];   
    ```

-   在建立数组时，同样要调用构造函数。如果有50个元素，需要调用50次构造函数。在需要时可以在定义数组时提供实参以实现初始化。

-   如果构造函数只有一个参数，在定义数组时可以直接在等号后面的花括号内提供实参。	

    ```c++
    Student::Student(int);
    Student stud[3]={60,70,78};
    ```

-   如果构造函数有多个参数，则不能用在定义数组时直接提供所有实参的方法。很容易造成实参与形参的对应关系不清晰，出现歧义性。

    ```c++
    //类Student的构造函数有多个参数，且为默认参数： 
    	Student∷ Student(int=1001,int=18,int=60); 
    
    //定义对象数组为：
    	Student stud[3]={1005,60,70};    //有歧义
    	Student stud[3]={60,70,78,45};   //不合法
    ```

    

-   如果构造函数有多个参数，在定义对象数组时应当在花括号中分别写出构造函数并指定实参。

    ```c++
    //如果构造函数有3个参数，分别代表学号、年龄、成绩。则可以这样定义对象数组： 
    Student Stud[3]=
    {//定义对象数组
    	Student(1001,18,87),  //调用第1个元素的构造函数
        Student(1002,19,76),  //调用第2个元素的构造函数
        Student(1003,18,72)   //调用第3个元素的构造函数
    };
    ```

```C++
//例3.6
//对象数组的使用方法。

#include <iostream>
using namespace std;
class Box
{
    public:
	//声明有默认参数的构造函数
		Box(int h=10,int w=12,int len=15):height(h),width(w),length(len){}
		int volume( );
    private:
        int height;
        int width;
        int length;
};
int Box∷volume( )
{
    return(height*width*length);
}
int main( )
{
    Box a[3]=
    {//定义对象数组
		Box(10,12,15),//调用构造函数Box，提供第1个元素的实参
        Box(15,18,20),//调用构造函数Box，提供第2个元素的实参
        Box(16,20,26)//调用构造函数Box，提供第3个元素的实参
    };
    cout<<″volume of a[0] is ″<<a[0].volume( )<<endl;   
    cout<<″volume of a[1] is ″<<a[1].volume( )<<endl;    
    cout<<″volume of a[2] is ″<<a[2].volume( )<<endl; 
}
```

### 3.5 对象指针

#### 3.5.1 指向对象的指针

-   在建立对象时，会为每一个对象分配存储空间，空间的起始地址就是对象的指针。

    <img src="https://raw.githubusercontent.com/LvFinch/ImgHost/master/Images/image-20200523101141379.png" alt="image-20200523101141379" style="zoom: 80%;" />

    ```c++
    class Time
    {
        public: 
        	int hour;
        	int minute;
    		int sec;
        	void get_time( );
    };
    void Time∷get_time( )//在类外定义set_time函数
    {
        cout<<hour<<“:”<<minute<<“:”<<sec;
    }
    ```

-   定义指向类对象的指针变量的一般形式：
    **类名   *对象指针名**

    >   ```c++
    >   *pt
    >   (*pt).hour =等价= pt->hour
    >   (*pt).get_time( ) =等价= pt->get_time( )
    >   ```

#### 3.5.2 指向对象成员的指针

##### 1. 指向对象数据成员的指针

-   定义形式：
        **数据类型名  *指针变量名**；

    ```c++
    int *p1;
    p1 = &t1.hour;
    cout<<*p1<<endl;
    ```

##### 2. 指向对象成员函数的指针

-   普通定义形式：
        **数据类型名  (*指针变量名)(参数列表)；**

    ```C++
    void (*p)( );
    p=fun;
    (*p)( );
    p=t1.get_time;//错误
    ```

-   指向成员函数的定义形式：
        **数据类型名  (类名::*指针变量名)(参数列表)；**

    ```c++
    void (Time :: *p2)( );
    ```

    ​    **指针变量名=&类名::成员函数名;**

    ```c++
    p2=[&]Time::get_time;
    (*p)( );
    ```

```c++
//例3.7
//对象指针的使用方法。

#include <iostream>
using namespace std;
class Time
{
    public:
    	Time(int,int,int);
    	int hour;
    	int minute;
    	int sec;
    	void get_time();
};

Time::Time(int h,int m,int s)
{
    hour=h;
    minute=m;
    sec=s;
}
void Time::get_time()
{
    cout<<hour<<":"<<minute<<":"<<sec<<endl;
}

int main()
{
    Time t1(10,13,56);
    int *p1=&t1.hour;
  	cout<<*p1<<endl;
  	t1.get_time();
  	Time *p2=&t1;
  	p2->get_time();
  	void (Time::*p3)();
  	p3=&Time::get_time;
  	(t1.*p3)();
  	return 0;
}
```

#### 3.5.3 this指针

-   同一类的n个对象有n组相同大小的空间存放n个对象中的数据成员，但是不同的对象却调用相同的函数代码段。

-   每一个成员函数中都包含一个特殊的指针，这个指针的名字是固定的，称为this。

-   this是指向本来对象的指针，其值为当前被调用的成员函数所在的对象的起始地址。

    ```C++
    //例如，调用a.volume ()实际上是执行
    (this->height)*(this->width)*(this->length)
    //相当于
    (a.height)*(a.width)*(a.length)
    ```

-   this指针是隐式使用的，是作为函数参数传递给成员函数的

    ```c++
    //如：
    int Box∷volume( )
    {
        return(height*width*length);
    }
    //处理为
    int Box∷volume( Box *this)
    {
        return(this->height*this->width*this->length);
    }
    //调用方式为：a.volume(&a);
    ```

-   有需要的时候可以显示的使用this

-   可用`*this`表示被调用成员函数所在的对象，即`*this`就是this所指向的对象，

    ```c++
    //如：
    return((*this).height*(*this).width)*(*this).length))
    ```

-   调用对象a的成员函数f，实际上就是在调用成员函数时使用this指针指向对象a，从而访问对象a的成员。

### 3.6 共用对象的保护

-   既要使数据在一定范围内共享，又不愿它被随意修改，从技术上可以把数据指定为**只读型**的。
-   C++提供const手段，将数据、对象、成员函数指定为常量，从而实现了只读要求，达到保护数据的目的。

#### 3.6.1 常对象

-   定义格式：

    **const 类名 对象名(实参表)；**

    或：

    **类名 const 对象名(实参表)；**

    把对象定义为常对象，对象中的数据成员就是常变量，在定义时必须带实参作为数据成员的初值，在程序中**不允许修改**常对象的数据成员值。

-   如果一个常对象的成员函数未被定义为常成员函数（除构造函数和析构函数外），则对象不能调用这样的成员函数。

    ```c++
    //如：
    const Time t1( 10,15,36);
    t1.get_time();//错误，不能调用
    ```

     	为了访问常对象中的数据成员，要定义常成员函数：

    ```c++
    void  get_time()  const
    ```

       **但仍然不能修改常对象中数据成员的值**。

-   如果在常对象中要修改某个数据成员，C++提供了指定可变的数据成员方法。
    	格式： **mutable   类型  数据成员；**
    在定义数据成员时加mutable后，将数据成员声明为可变的数据成员，就可以用声明为const的成员函数修改它的值。

#### 3.6.2 常对象成员

##### 1. 常数据成员

-   ##### 格式：  **const  类型  数据成员名**
	将类中的数据成员定义为具有只读的性质。
	**注意**只能通过带参数初始表的构造函数对常数据成员进行初始化。

    ```c++
    //例：
    const   int  hour;
    Time :: Time( int h )
    {hour = h;}//错误
    //应该写成：
    Time :: Time( int h ) : hour (h) {}
    ```

-   在类中声明了某个常数据成员后，该类中每个对象的这个数据成员的值都是只读的，而每个对象的这个数据成员的值可以不同，由定义对象时给出。

##### 2. 常成员函数

-   定义格式：
    	       **类型    函数名    (形参表)   const**

    const 是函数类型的一部分，在声明函数原型和定义函数时都要用const关键字。

-   常成员函数不能修改对象的数据成员，也不能调用该类中没有由关键字const修饰的成员函数，从而保证了在常成员函数中不会修改数据成员的值。
-   如果一个对象被说明为常对象，则通过该对象只能调用它的常成员函数。
-   一般成员函数可以访问或修改本类中的非 const数据成员。而常成员函数只能读本类中的数据成员，而不能写它们。

![image-20200523105137902](https://raw.githubusercontent.com/LvFinch/ImgHost/master/Images/image-20200523105137902.png)

-   如果类中有部分数据成员的值要求为只读，可以将它们声明为const，这样成员函数只能读这些数据成员的值，但不能修改它们的值。
-   如果所有数据成员的值为只读，可将对象声明为const，在类中必须声明const 成员函数，常对象只能通过常成员函数读数据成员。
-   常对象不能调用非const成员函数。
     	**提醒**：如果常对象的成员函数未加const，编译系统将其当作非const成员函数；常成员函数不能调用非const成员函数。

#### 3.6.3 指向对象的常指针

-   如果在定义指向对象的指针时，使用了关键字 const ， 它就是一个常指针，必须在定义时对其初始化。并且在程序运行中不能再修改指针的值。
       **类名 * const 指针变量名 = 对象地址**

```C++
//例：
Time t1(10,12,15)，t2;
Time * const p1 = & t1;
//在此后，程序中不能修改p1。
//例：
Time * const p1 = & t2;//错误语句
```

-   指向对象的常指针，在程序运行中始终指的是同一个对象。即指针变量的值始终不变，但它所指对象的数据成员值可以修改。
-   当需要将一个指针变量固定地与一个对象相联系时，就可将指针变量指定为const。
-   往往用常指针作为函数的形参，目的是不允许在函数中修改指针变量的值，让它始终指向原来的对象。

#### 3.6.4 指向常对象的指针变量

-   首先了解指向常变量的指针变量 
                   const char *ptr;

    注意const的位置在最左侧，它与类型名char紧连，表示指针变量ptr指向的char变量是常变量，不能通过ptr来改变其值的。

-   定义指向常变量的指针变量的一般形式为
                    **const 类型名 *指针变量名；**

-   如果一个变量已被声明为常变量，只能用指向常变量的指针变量指向它，而不能用一般的(指向非const型变量的)指针变量去指向它。

-   指向常变量的指针变量除了可以指向常变量外，还可以指向未被声明为const的变量。此时不能通过此指针变量改变该变量的值。如果希望在任何情况下都不能改变c1的值，则应把它定义为const型。

-   如果函数的形参是指向非const型变量的指针，实参只能用指向非const变量的指针，而不能用指向const变量的指针，这样，在执行函数的过程中可以改变形参指针变量所指向的变量(也就是实参指针所指向的变量)的值。

-   如果函数的形参是指向const型变量的指针，在执行函数过程中显然不能改变指针变量所指向的变量的值，因此允许实参是指向const变量的指针，或指向非const变量的指针。指向常对象的指针变量的概念和使用是与此类似的，只要将“变量”换成“对象”即可。

-   如果一个对象已被声明为常对象，只能用指向常对象的指针变量指向它，而不能用一般的(指向非const型对象的)指针变量去指向它。

-   如果定义了一个指向常对象的指针变量，并使它指向一个非const的对象，则其指向的对象是不能通过指针来改变的。如果希望在任何情况下t1的值都不能改变，则应把它定义为const型。

-   指向常对象的指针最常用于函数的形参，目的是在保护形参指针所指向的对象，使它在函数执行过程中不被修改。

-   当希望在调用函数时对象的值不被修改，就应当把形参定义为指向常对象的指针变量，同时用对象的地址作实参(对象可以是const或非const型)。如果要求该对象不仅在调用函数过程中不被改变，而且要求它在程序执行过程中都不改变，则应把它定义为const型。

-   如果定义了一个指向常对象的指针变量，是不能通过它改变所指向的对象的值的，但是指针变量本身的值是可以改变的。

#### 3.6.5 对象的常引用

-   一个变量的引用就是变量的别名。实质上，变量名和引用名都指向同一段内存单元。如果形参为变量的引用名，实参为变量名，则在调用函数进行虚实结合时，并不是为形参另外开辟一个存储空间(常称为建立实参的一个拷贝)，而是把实参变量的地址传给形参(引用名)，这样引用名也指向实参变量。

```c++
//例3.8
//对象的常引用。

#include <iostream>
using namespace std;
class Time
{
    public:
    	Time(int,int,int);
        int hour;
        int minute;
        int sec;
};

Time∷Time(int h,int m,int s)//定义构造函数
{
    hour=h;
    minute=m;
    sec=s;
}
void fun(Time &t)//形参t是Time类对象的引用 
{
    t.hour=18;
}
int main( )
{
    Time t1(10,13,56);// t1是Time类对象
    fun(t1);//实参是Time类对象，可以通过引用来修改实参t1的值
	cout<<t1.hour<<endl;//输出t1.hour的值为18
    return 0;
}
```

如果不希望在函数中修改实参t1的值，可以把引用变量t声明为const(常引用)，函数原型为

则在函数中不能改变t的值，也就是不能改变其对应的实参t1的值。

```c++
void fun(const Time &t);
```

则在函数中不能改变t的值，也就是不能改变其对应的实参t1的值。

-   在C++面向对象程序设计中，经常用常指针和常引用作函数参数。这样既能保证数据安全，使数据不能被随意修改，在调用函数时又不必建立实参的拷贝。用常指针和常引用作函数参数，可以提高程序运行效率。 

#### 3.6.6 const数据类型的小结

![image-20200523110535409](https://raw.githubusercontent.com/LvFinch/ImgHost/master/Images/image-20200523110535409.png)

### 3.7 对象的动态建立和释放

-   可以用new运算符动态建立对象，用delete运算符撤销对象。

-   如果已经定义了一个Box类，可以用下面的方法动态地建立一个对象：编译系统开辟了一段内存空间，并在此内存空间中存放一个Box类对象，同时调用该类的构造函数，以使该对象初始化(如果已对构造函数赋予此功能的话)。但是此时用户还无法访问这个对象，因为这个对象既没有对象名，用户也不知道它的地址。这种对象称为无名对象，它确实是存在的，但它没有名字。

-   用new运算符动态地分配内存后，将返回一个指向新对象的指针的值，即所分配的内存空间的起始地址。用户可以获得这个地址，并通过这个地址来访问这个对象。需要定义一个指向本类的对象的指针变量来存放该地址。

    ```c++
    Box *pt;//定义一个指向Box类对象的指针变量pt
    pt=new Box;//在pt中存放了新建对象的起始地址
    //在程序中就可以通过pt访问这个新建的对象。如 
    cout<<pt->height;//输出该对象的height成员
    cout<<pt->volume( );//调用该对象的volume函数，计算并输出体积
    ```

-   C++还允许在执行new时，对新建立的对象进行初始化。

    ```C++
    //如
    Box *pt=new Box(12,15,18);
    ```

-   调用对象既可以通过对象名，也可以通过指针。用new建立的动态对象一般是不用对象名的，是通过指针访问的，它主要应用于动态的数据结构，如链表。访问链表中的结点，并不需要通过对象名，而是在上一个结点中存放下一个结点的地址，从而由上一个结点找到下一个结点，构成链接的关系。

-   在执行new运算时，如果内存量不足，无法开辟所需的内存空间，目前大多数C++编译系统都使new返回一个0指针值。只要检测返回值是否为0，就可判断分配内存是否成功。

-   在不再需要使用由new建立的对象时，可以用delete运算符予以释放。

    ```c++
    //如
    delete pt;//释放pt指向的内存空间
    //这就撤销了pt指向的对象。此后程序不能再使用该对象。
    ```

-   如果用一个指针变量pt先后指向不同的动态对象，应注意指针变量的当前指向，以免删错了对象。
-   在执行delete运算符时，在释放内存空间之前，自动调用析构函数，完成有关善后清理工作。

### 3.8 对象的赋值和复制

#### 3.8.1 对象的赋值

-   对象之间的赋值也是通过赋值运算符“=”进行。一般形式为
                **对象名1 = 对象名2;**
       对象名1和对象名2必须属于同一个类。

    ```C++
    //例如
    Student stud1,stud2;//定义两个同类的对象
    //┆
    stud2=stud1;//将stud1赋给stud2
    ```

```C++
//例3.9
//对象的赋值。

#include <iostream>
using namespace std;
class Box
{
    public:
		Box(int=10,int=10, int=10);//声明有默认参数的构造函数
        int volume( );
    private:
        int height;
        int width;
        int length;
};
Box∷Box(int h,int w,int len)
{
    height=h;
    width=w;
    length=len;
} 
int main( )
{   
    Box box1(15,30,25),box2;//定义两个对象box1和box2
    cout<<″The volume of box1 is ″<<box1.volume( )<<endl;
	box2=box1;//将box1的值赋给box2
	cout<<″The volume of box2 is ″<<box2.volume( )<<endl;
	return 0;
}

运行结果如下： 
The volume of box1 is 11250
The volume of box2 is 11250
(1) 对象的赋值只对其中的数据成员赋值，而不对成员函数赋值。
(2) 类的数据成员中不能包括动态分配的数据，否则在赋值时可能出现严重后果。
```

#### 3.8.2 对象的复制

-   对象的复制机制就是将对象在某一瞬时的状态保留下来。即用一个已有的对象快速地复制出多个完全相同的对象。如
             Box box2(box1);
       其作用是用已有的对象box1去克隆出一个新对象box2。
-   其一般形式为
            **类名 对象2(对象1)；**
        用对象1复制出对象2。

-   C++还有另一种复制形式，用赋值号代替括号，如
            Box box2=box1;          //用box1初始化box2
       其一般形式为
            **类名 对象名1 = 对象名2；**
-   可以在一个语句中进行多个对象的复制。如
              Box box2=box1,box3=box2;
       按box1来复制box2和box3。

```C++
int main( )
 {
    Box box1(15,30,25);//定义box1
    cout<<box1.volume( )<<endl;
	Box box2=box1,box3=box2; //按Box1复制box2,box3
	cout<<box2.volume( )<<endl;
	cout<<box3.volume( )<<endl;
 }
```

-   赋值和赋值的区别：
       **对象的赋值**是对一个已经存在的对象赋值，因此必须先定义被赋值的对象，才能进行赋值；
       **对象的复制**则是从无到有地建立一个新对象，并使它与一个已有的对象完全相同(包括对象的结构和成员的值)。

-   普通构造函数和复制构造函数的区别：

    -   **形式上**
           类名(形参列表)；//普通构造函数Box(int h,int w);
           类名(类名&对象名);  //复制构造函数Box(Box &b);

    -   **建立对象时，实参类型不同**
           Box box1(12,15,16);//实参是整数,调用普通构造函数
           Box box2(box1);//实参是对象名,调用复制构造函数

    -   **在什么情况下调用**
           普通构造函数在建立对象时调用；
           复制构造函数用已有对象复制一个新对象时被调用：

        -   在程序中需要建立一个新对象，并用另一个同类的对象初始化时

        -   当函数的参数是类的对象时；

            ```C++
            void fun(Box b){}
            int main()
            {
                Box box1(12,15,18);
                fun(box1);//调用函数时将复制一个新对象b
                return 0;
            }
            ```

        -   函数的返回值是类的对象；

            ```c++
            Box f()
            {
                Box box1(12,15,18);
                return box1;
            }
            int main()
            {
                Box box2;
                box2=f();//调用f函数，返回Box类的临时对象
            }
            ```

            