# 面向对象分析与设计

## 第三章 关于类和对象的进一步讨论

### 3.1 构造函数

#### 3.1.1 对象的初始化

-   类的数据成员是不能在**声明**类时初始化

    ```c++
    class Time
    {       
    	hour=0;       //错误
    	minute=0;
    	sec=0;
    };
    ```

-   因为类不是一个实体，是一种抽象类型，不占存储空间，所以不能容纳数据

-   如果一个类中所有的成员都是公用的，则可以在定义对象时对数据成员进行初始化。

    ```c++
    class Time
    {     
        public:                 //声明为公用成员
        	hour;                        
            minute;
            sec;
    };
    Time t1={14,56,30};         //将t1初始化为14:56:30
    ```

#### 3.1.2 构造函数的作用

-   C++提供了**构造函数**(constructor)来处理对象的初始化。
-   构造函数是一种**特殊的成员函数**，不需要用户来调用它，而是在建立对象时**自动执行**。
-   构造函数的名字必须与**类名同名**，而不能由用户任意命名。它**不具有任何类型，不返回任何值**。

```c++
//例3.1
//在例2.3基础上定义构造成员函数。

#include <iostream>
using namespace std;
class Time
{   
    public:
        Time( )             //定义构造成员函数，函数名与类名相同
        {   
            hour=0;       //利用构造函数对对象中的数据成员赋初值
            minute=0;
            sec=0;  
        }
         void set_time( );           //函数声明
         void show_time( );          //函数声明
    private:
         int hour;                  //私有数据成员
         int minute;
         int sec;   
};
void Time∷set_time( )        //定义成员函数，向数据成员赋值
{   
    cin>>hour;
	cin>>minute;
	cin>>sec;
}
void Time∷show_time( )    //定义成员函数，输出数据成员的值
{
	cout<<hour<<″:″<<minute<<″:″<<sec<<endl;
}
int main( )
{
	Time t1;            //建立对象t1，同时调用构造函数t1.Time( )
	t1.set_time( );             //对t1的数据成员赋值
	t1.show_time( );            //显示t1的数据成员的值 
	Time t2;           //建立对象t2，同时调用构造函数t2.Time( )
	t2.show_time( );            //显示t2的数据成员的
	return 0;
}
```

在类外定义构造函数:

```c++
Time∷Time( ) 
{
     hour=0;                 
     minute=0;
     sec=0;
}
```

-   在类对象进入其作用域时调用构造函数。
-   构造函数没有返回值，因此也不需要在定义构造函数时声明类型。
-   构造函数不需用户调用，也不能被用户调用。
-   在构造函数的函数体中不仅可以对数据成员赋初值，而且可以包含其他语句。
-   如果用户自己没有定义构造函数，则C++系统会自动生成一个构造函数，该构造函数的函数体是空的，也没有参数，不执行初始化操作。

#### 3.1.3 带参数的构造函数

-   带参数的构造函数，在调用不同对象的构造函数时，从外面将不同的数据传递给构造函数，以实现不同的初始化。
-   构造函数首部的一般格式为
           **构造函数名(类型 1 形参1，类型2 形参2，…)**
        实参是在定义对象时给出的。
        定义对象的一般格式为 
            **类名 对象名(实参1，实参2，…);**

```C++
//例3.2
//有两个长方柱，其长、宽、高分别为： (1)12,20,25；(2)10,14,20。求它们的体积。

#include <iostream>
using namespace std;
class Box
{  
	public:
		Box(int,int,int);        //声明带参数的构造函数
        int volume( );            //声明计算体积的函数
	private:
        int height;
        int width;
        int length;
};
Box∷Box(int h,int w,int len)   //在类外定义带参数的构造函数
{    
    height=h;
	width=w;
	length=len;
}
int Box∷volume( )                //定义计算体积的函数
{
     return(height*width*length);
}

int main( )
{
      Box box1(12,25,30);      //建立对象box1
      cout<<″The volume of box1 is ″<<box1.volume( )<<endl;
      Box box2(15,30,21);           //建立对象box2 
      cout<<″The volume of box2 is ″<<box2.volume( )<<endl;
      return 0;
}
```

#### 3.1.4 用参数初始化表对数据成员初始化

-   不在函数体内对数据成员初始化，而是在函数首部实现。
-   一般格式为
       **Box∷Box(int h,int w,int len): height(h),width(w), length(len){ }**

#### 3.1.5 构造函数的重载

-   在一个类里可以定义多个构造函数，所有的构造函数都同名，只是参数的个数或参数的类型不同。

```c++
//例3.3
//在例3.2的基础上，定义两个构造函数，其中一个无参数，一个有参数。

#include <iostream>
using namespace std;
class Box
{
    public:
		Box( );//声明一个无参的构造函数
		Box(int h,int w,int len):height(h),width(w),length(len){ }//声明一个有参的构造函数
		int volume( );
	private:
		int height;
    	int width;
    	int length;
};
Box∷Box( )//定义一个无参的构造函数
{   
	height=10;
    width=10;
    length=10;
}
int Box∷volume( )
{return(height*width*length);}

int main( )
{
    Box box1;//建立对象box1,不指定实参
    cout<<″The volume of box1 is ″<<box1.volume( )<<endl;
    Box box2(15,30,25);//建立对象box2,指定3个实参
    cout<<″The volume of box2 is ″<<box2.volume( )<<endl;
    return 0;
}

在本程序中定义了两个重载的构造函数，其实还可以定义其他重载构造函数，其原型声明可以为
Box∷Box(int h)；                    //有1个参数的构造函数
Box∷Box(int h,int w)；              //有两个参数的构造函数
在建立对象时分别给定1个参数和2个参数。
```

-   调用构造函数时不必给出实参的构造函数，称为默认构造函数(default constructor)。无参的构造函数属于默认构造函数。一个类只能有一个默认构造函数。
-   如果在建立对象时选用的是无参构造函数，应注意正确书写定义对象的语句。Box box1；Box box1();
-   尽管在一个类中可以包含多个构造函数，但是对于每一个对象来说，建立对象时只执行其中一个构造函数，并非每个构造函数都被执行。

#### 3.1.6 带默认参数的构造函数

```c++
//例3.4

#include <iostream>
using namespace std;
class Box
{
    public:
    	Box(int h=10,int w=10,int len=10);//指定默认参数
        int volume( );//声明计算体积的函数
   private:
        int height;
        int width;
        int length;
};
Box∷Box(int h,int w,int len)//定义时不用再指定默认值
{    
    height=h;
	width=w;
	length=len;
}
int Box∷volume( )
{
    return(height*width*length);
}
int main( )
{
    Box box1;//没有给实参 
	cout<<″The volume of box1 is ″<<box1.volume( )<<endl;
	Box box2(15);//只给定一个实参
	cout<<″The volume of box2 is ″<<box2.volume( )<<endl;
	Box box3(15,30);//只给定2个实参
	cout<<″The volume of box3 is ″<<box3.volume( )<<endl;
	Box box4(15,30,20);//给定3个实参
    cout<<″The volume of box4 is ″<<box4.volume( )<<endl;
    return 0;
}
```

-   要在**声明**构造函数时指定默认值，而不能只在定义构造函数时指定默认值。
-   在声明构造函数时，形参名可以省略。
               Box(int=10,int=10,int=10);
-   如果构造函数的全部参数都指定了默认值，则在定义对象时可以给一个或几个实参，也可以不给出。
-   一个类只能有一个默认构造函数。
               Box();
               Box(int=10,int=10,int=10);
               Box box1;？
-   重载时注意歧义出现
       Box();
       Box(int,int=10,int=10);
       Box(int,int);
       定义对象如下：
       Box box1; 
       Box box2(15); 
       Box box3(15,30);

### 3.2 析构函数

-   析构函数(destructor)也是一个特殊的成员函数，它的作用与构造函数相反，它的名字是类名的前面加一个“**～**”符号。
-   当对象的生命期结束时，会自动执行析构函数。
    -   ①如果在一个函数中定义了一个对象(它是自动局部对象)，当这个函数被调用结束时，对象应该释放，在对象释放前自动执行析构函数。
    -   ②在main函数结束或调用exit函数结束程序时，调用static局部对象的析构函数。 
    -   ③如果定义了一个全局对象，则在程序的流程离开其作用域时(如main函数结束或调用exit函数) 时，调用该全局对象的析构函数。
    -   ④如果用new运算符动态地建立了一个对象，当用delete运算符释放该对象时，先调用该对象的析构函数。

-   析构函数不是删除对象，而是在撤销对象占用的内存之前完成一些清理工作，使这部分内存可以被程序分配给新对象使用。
-   析构函数不返回任何值，没有函数类型，也没有函数参数。因此它不能被重载。**一个类可以有多个构造函数，但只能有一个析构函数。**
-   析构函数的作用并不仅限于释放资源方面，它还可以完成类的设计者所指定的任何操作。
-   一般情况下，应当在声明类的同时定义析构函数。如果用户没有定义析构函数，C++编译系统会自动生成一个析构函数，但什么操作都不进行。

### 3.3调用构造函数和析构函数的顺序

-   调用析构函数的次序正好与调用构造函数的次序相反： 最先被调用的构造函数，其对应的(同一对象中的)析构函数最后被调用，而最后被调用的构造函数，其对应的析构函数最先被调用。
-   **先构造后析构，后构造先析构。**
-   但有时会受生命期和作用域的影响

### 3.4 对象数组

-   数组可以由对象组成(对象数组的每一个元素都是同类的对象)。

    >   例如： Student stud[50];   

-   在建立数组时，同样要调用构造函数。如果有50个元素，需要调用50次构造函数。在需要时可以在定义数组时提供实参以实现初始化。

-   如果构造函数只有一个参数，在定义数组时可以直接在等号后面的花括号内提供实参。

    >   例如：
    >
    >   ​	Student::Student(int);
    >
    >   ​	Student stud[3]={60,70,78};

-   如果构造函数有多个参数，则不能用在定义数组时直接提供所有实参的方法。很容易造成实参与形参的对应关系不清晰，出现歧义性。

    >      例如：
    >
    >   类Student的构造函数有多个参数，且为默认参数： 
    >   	Student∷ Student(int=1001,int=18,int=60); 
    >
    >   定义对象数组为：
    >   	Student stud[3]={1005,60,70};    //有歧义
    >   	Student stud[3]={60,70,78,45};   //不合法